#include "DoubleMassSpringDamper_macros.h"
/*
 * Copyright 2026 The MathWorks, Inc.
 *
 * File    : DoubleMassSpringDamper_fmu.c
 *
 * Abstract:
 *      FMI target wrapper generated by Simulink.
 *
 */

/*==================*
 * Required defines *
 *==================*/

#ifndef MODEL
# error Must specify a model name.  Define MODEL=name.
#else
/* create generic macros that work with any model */
# define EXPAND_CONCAT(name1,name2) name1 ## name2
# define CONCAT(name1,name2) EXPAND_CONCAT(name1,name2)
# define MODEL_INITIALIZE CONCAT(MODEL,_initialize)
# define MODEL_OUTPUT     CONCAT(MODEL,_output)
# define MODEL_UPDATE     CONCAT(MODEL,_update)
# define MODEL_TERMINATE  CONCAT(MODEL,_terminate)
# define RT_MDL_TYPE      RT_MODEL_DoubleMassSpringDamper_T
#endif
#define QUOTE1(name) #name
#define QUOTE(name) QUOTE1(name)    /* need to expand name    */
/*==========*
 * Includes *
 *==========*/
#include <math.h>
#include <time.h>
#include <stdio.h>   /* optional for printf */
#include <string.h>  /* optional for strcmp */
#include <inttypes.h> /* macros for working with integer types */
#include <stdarg.h> /* for handling variable len args */
#include "rtmodel.h" /* optional for automated builds */
#include "DoubleMassSpringDamper.h"
#include "DoubleMassSpringDamper_private.h"
#include "fmi3Functions.h"
#include "RTWCG_util_functions.h"

/*====================*
 * External functions *
 *====================*/
extern void MODEL_INITIALIZE();
extern void MODEL_TERMINATE();
extern void MODEL_OUTPUT();
extern void MODEL_UPDATE();
/*==================================*
 * Global data local to this module *
 *==================================*/
const char *RT_MEMORY_ALLOCATION_ERROR = "memory allocation error"; 
typedef enum {
    Float64,
    Float32,
    Int8,
    UInt8,
    Int16,
    UInt16,
    Int32,
    UInt32,
    Int64,
    UInt64,
    Boolean,
    Clock,
    Undefined
} DataType;
typedef void      (*FMU2_CallbackLogger)        (void* componentEnvironment,
                                const char* instanceName,
                                unsigned int status,
                                const char* category,
                                const char* message,
                                ...);
typedef void*     (*FMU2_CallbackAllocateMemory)(size_t nobj, size_t size);
typedef void      (*FMU2_CallbackFreeMemory)    (void* obj);
typedef void      (*FMU2_StepFinished)          (void* componentEnvironment,
                                                unsigned int status);
typedef struct {
    /* Local definition of FMU2_CallbackFunctions */
    FMU2_CallbackLogger         logger;
    FMU2_CallbackAllocateMemory allocateMemory;
    FMU2_CallbackFreeMemory     freeMemory;
    FMU2_StepFinished           stepFinished;
    void*   componentEnvironment;
} FMU2_CallbackFunctions;
typedef struct {
    /* Model data */
    RT_MDL_TYPE *S;
    /* FMU data*/
    fmi3String instanceName;
    fmi3String instantiationToken;
    fmi3String resourceLocation;
    fmi3LogMessageCallback logMessage;
    FMU2_CallbackFunctions *functions;
    fmi3IntermediateUpdateCallback intermediateUpdate;
    fmi3InstanceEnvironment        instanceEnvironment;
    fmi3Boolean visible;
    fmi3Boolean eventModeUsed;
    fmi3Boolean eventProcessed;
    fmi3Boolean loggingOn;
    fmi3Boolean initialized;
    fmi3Float64 time;
    fmi3Boolean isDirty;
    fmi3Float64 *derivsBuffer;
    /* Variable Indices */
    float **float32List;
    int32_T *float32ListSize;
    int32_T **float32ListDims;
    real_T **rList;
    int32_T *rListSize;
    int32_T **rListDims;
    real_T *rBuffer;
    int8_T **i8List;
    int32_T *i8ListSize;
    int32_T **i8ListDims;
    uint8_T **ui8List;
    int32_T *ui8ListSize;
    int32_T **ui8ListDims;
    int16_T **i16List;
    int32_T *i16ListSize;
    int32_T **i16ListDims;
    uint16_T **ui16List;
    int32_T *ui16ListSize;
    int32_T **ui16ListDims;
    int32_T **i32List;
    int32_T *i32ListSize;
    int32_T **i32ListDims;
    uint32_T **ui32List;
    int32_T *ui32ListSize;
    int32_T **ui32ListDims;
    int64_T **i64List;
    int64_T *i64Buffer;
    int32_T *i64ListSize;
    int32_T **i64ListDims;
    uint64_T **ui64List;
    int32_T  *ui64ListSize;
    int32_T  **ui64ListDims;
    int32_T *iBuffer;
    boolean_T **bList;
    int32_T *bListSize;
    int32_T **bListDims;
    char **sList;
    int32_T *sSize;
    /* Output Buffers */
    float *float32Output;
    real_T *rOutput;
    int8_T *i8Output;
    uint8_T *ui8Output;
    int16_T *i16Output;
    uint16_T *ui16Output;
    int32_T *i32Output;
    uint32_T *ui32Output;
    int64_T *i64Output;
    uint64_T *ui64Output;
    boolean_T *bOutput;
    char **sOutput;
    /*supporting variables related to array processing */
    int idxVector[1];
    int inDim[1];
    
    /*lists related to FMI 3.0 clock variables*/
    fmi3Clock *fmi3ClockList;
    real_T *fmi3ClockInterval;
    real_T *fmi3ClockShift;
} FMUModelData;
FMUModelData *_instance = NULL;
 
void fmu_syncToBuffer(void) {
 
}
 
void fmu_syncFromBuffer(void) {
 
}
 
void fmu_LogOutput(void) {
    int i;
    FMUModelData *modelData = (FMUModelData *)_instance;
    int arrIdsFloat64[] = {0, 1};
    for(i=0; i<2; i++){
        modelData->rOutput[i] = *(modelData->rList[arrIdsFloat64[i]]);
    }
}
 
void fmu_RestoreOutput(void) {
    int i;
    FMUModelData *modelData = (FMUModelData *)_instance;
    int arrIdsFloat64[] = {0, 1};
    for(i=0; i<2; i++){
        *(modelData->rList[arrIdsFloat64[i]]) = modelData->rOutput[i];
    }
}
 
const char* fmu_resourceLocation(void) {
    FMUModelData *modelData = (FMUModelData *)_instance;
    return (const char *)modelData->resourceLocation;
}

const void* fmu_callback(int fmuVersion) {
    FMUModelData *modelData = (FMUModelData *)_instance;
    if(fmuVersion <= 2) {
       return (const void *)modelData->functions;
    }
    else if(fmuVersion == 3) {
       return (const void *)modelData->logMessage;
    }
    else {
       return NULL;
    }
}

int fmu_fmuVisible(void) {
    FMUModelData *modelData = (FMUModelData *)_instance;
    return (int)modelData->visible;
}

int fmu_fmuLogging(void) {
    FMUModelData *modelData = (FMUModelData *)_instance;
    return (int)modelData->loggingOn;
}

char* fmu_instanceName(void) {
    FMUModelData *modelData = (FMUModelData *)_instance;
    return (char*)modelData->instanceName;
}

int fmu_restoreSimScapeInitialState(void) {
    return 0;
}
/*====================*
 *  Static functions  *
 *====================*/
static void FMU2_loggerWrapper(void* componentEnvironment,
                        const char* instanceName,
                        unsigned int status,
                        const char* category,
                        const char* message, ...) {
    (void) (instanceName);
    FMUModelData *modelData = (FMUModelData *)_instance;
    if(modelData != NULL && modelData->logMessage != NULL) {
       char formattedMsg[1024];
       va_list args;
       va_start (args, message);
       vsnprintf(formattedMsg, 1024, message, args);
       va_end(args);
        modelData->logMessage(componentEnvironment, (fmi3Status)status, category, formattedMsg);
    }
}
static void rtOneStep(RT_MDL_TYPE *S) {
    (void)S;
    DoubleMassSpringDamper_output();
    DoubleMassSpringDamper_derivatives();
}
/*================================================================*
 * Functions to support LinIdx for Row-major and Col-major arrays *
 *================================================================*/

static void incrementIdxVector( int  *idxVector,  const int *inDim, const int  nDim) {
    int  i;
    if (!idxVector || !inDim)
        return;

    i = nDim-1;
    while (i >= 0) {
           idxVector[i]++;
           if (idxVector[i] >= inDim[i] )
               idxVector[i--] = 0;
           else
               break;
    }
}

static int getColMajorLinIdxFromIdxVec(const int *idxVector, const int *inDim, const int nDim){
    int linIdx, stride, i;
    if (!idxVector || !inDim)
        return -1;
    linIdx=0;
    stride=1;
    for(i = 0; i < nDim; ++i) {
         linIdx += stride*idxVector[i];
         stride *= inDim[i];
    }
    return linIdx;
}

static int getRowMajorLinIdxFromIdxVec(const int *idxVector, const int *inDim, const int nDim){
    int linIdx, stride, i;
    if (!idxVector || !inDim)
        return -1;
    int numOfTotalElements = 1;
    for (i=0; i<nDim; i++)
         numOfTotalElements *= inDim[i];
    linIdx=0;
    stride = numOfTotalElements;
    for (i=0; i<nDim; i++)
    {
        stride /= inDim[i];
        linIdx += stride*idxVector[i];
    }
    return linIdx;
}
static void updateArrayData(int *idxVector, int *inDim, void *mList, int mListSize, int *mListDims,
    void *value, bool updateRow, size_t datasize, bool *is_diff_value ){
    if (!idxVector || !inDim|| !mList || !mListDims || !value)
       return;

    if (mListSize==1 || mListDims[0]==1 || (mListDims[0] == 2 && (mListDims[1]==1 || mListDims[2]==1))){
       if (updateRow) 
          memcpy(value, mList, datasize*mListSize);
       else{
          if (memcmp(mList, value, datasize * mListSize) != 0){
              *is_diff_value = fmi3True;
          }
          memcpy(mList, value, datasize*mListSize);
        }
    }
    else{
       int nDim, linIdx, j;
       nDim = mListDims[0];
       for (j = 0; j < nDim; j++){
          idxVector[j] = 0;
          inDim[j] = mListDims[j+1];
       }

       for (j = 0; j < mListSize; j++)
       {
           linIdx = getColMajorLinIdxFromIdxVec(idxVector, inDim, nDim);
           if (updateRow){
              memcpy(((char*)value + j*datasize), ((char*)mList + linIdx * datasize), datasize);
           }
           else{
               if (!is_diff_value && memcmp( ((char*)mList + linIdx*datasize), ((char*)value + j*datasize), datasize) != 0 ){
                  *is_diff_value = fmi3True;
               }
               memcpy( ((char*)mList + linIdx*datasize), ((char*)value + j*datasize), datasize);
           }
           incrementIdxVector(idxVector, inDim, nDim);
       }
   }
}

 
static DataType getDataType(const char* datatypeStr) {
    if (strcmp(datatypeStr, "Float64") == 0)
        return Float64;
    else if (strcmp(datatypeStr, "Float32") == 0)
        return Float32;
    else if (strcmp(datatypeStr, "Int8") == 0)
        return Int8;
    else if (strcmp(datatypeStr, "UInt8") == 0)
        return UInt8;
    else if (strcmp(datatypeStr, "Int16") == 0)
        return Int16;
    else if (strcmp(datatypeStr, "UInt16") == 0)
        return UInt16;
    else if (strcmp(datatypeStr, "Int32") == 0)
        return Int32;
    else if (strcmp(datatypeStr, "UInt32") == 0)
        return UInt32;
    else if (strcmp(datatypeStr, "Int64") == 0)
        return Int64;
    else if (strcmp(datatypeStr, "UInt64") == 0)
        return UInt64;
    else if (strcmp(datatypeStr, "Boolean") == 0)
        return Boolean;
    else if (strcmp(datatypeStr, "Clock") == 0)
        return Clock;
    else 
        return Undefined;
}

static void printLogMsg(fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const char* funMsg, const void* value, size_t startIdx, int* listSize){
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    if(!modelData || !modelData->loggingOn || !modelData->logMessage) return;
    DataType datatype = getDataType(funMsg + 3);
    int ind = 0;
    for(size_t i = 0; i<nvr; i++){
        size_t idx = vr[i] - startIdx;
        for (int j = 0; j < *(listSize + idx); j++) {
             char msgBuffer[255];
             switch (datatype) {
                 case Float64:
                      snprintf(msgBuffer, 255, "%s t:%f nvr:%zu vr:%d value:%lf", funMsg, modelData->time, nvr, vr[i], (double)*((fmi3Float64*)value + ind));
                      break;
                 case Float32:
                     snprintf(msgBuffer, 255, "%s t:%f nvr:%zu vr:%d value:%f", funMsg, modelData->time, nvr, vr[i], (float)*((fmi3Float32*)value + ind));
                     break;
                 case Int8:
                     snprintf(msgBuffer, 255, "%s t:%f nvr:%zu vr:%d value:%" PRId8, funMsg, modelData->time, nvr, vr[i], (int8_t)*((fmi3Int8*)value + ind));
                     break;
                 case UInt8:
                     snprintf(msgBuffer, 255, "%s t:%f nvr:%zu vr:%d value:%" PRIu8, funMsg, modelData->time, nvr, vr[i], (uint8_t)*((fmi3UInt8*)value + ind));
                     break;
                 case Int16:
                     snprintf(msgBuffer, 255, "%s t:%f nvr:%zu vr:%d value:%" PRId16, funMsg,  modelData->time, nvr, vr[i], (int16_t)*((fmi3Int16*)value + ind));
                     break;
                 case UInt16:
                     snprintf(msgBuffer, 255, "%s t:%f nvr:%zu vr:%d value:%" PRIu16, funMsg, modelData->time, nvr, vr[i], (uint16_t)*((fmi3UInt16*)value + ind));
                     break;
                 case Int32:
                     snprintf(msgBuffer, 255, "%s t:%f nvr:%zu vr:%d value:%" PRId32, funMsg, modelData->time, nvr, vr[i], (int32_t)*((fmi3Int32*)value + ind));
                     break;
                 case UInt32:
                     snprintf(msgBuffer, 255, "%s t:%f nvr:%zu vr:%d value:%" PRIu32, funMsg, modelData->time, nvr, vr[i], (uint32_t)*((fmi3UInt32*)value + ind));
                     break;
                 case Int64:
                     snprintf(msgBuffer, 255, "%s t:%f nvr:%zu vr:%d value:%" PRId64, funMsg, modelData->time, nvr, vr[i], (int64_t)*((fmi3Int64*)value + ind));
                     break;
                 case UInt64:
                     snprintf(msgBuffer, 255, "%s t:%f nvr:%zu vr:%d value:%" PRIu64, funMsg, modelData->time, nvr, vr[i], (uint64_t)*((fmi3UInt64*)value + ind));
                     break;
                 case Boolean:
                     snprintf(msgBuffer, 255, "%s t:%f nvr:%zu vr:%d value:%d", funMsg, modelData->time, nvr, vr[i], *((fmi3Boolean*)value + ind));
                     break;
                 case Clock:
                     snprintf(msgBuffer, 255, "%s t:%f nvr:%zu vr:%d value:%d", funMsg, modelData->time, nvr, vr[i], *((fmi3Clock*)value + ind));
                     break;
             }
            modelData->logMessage(modelData->instanceEnvironment, fmi3OK, "info", msgBuffer);
            ind = ind + 1;
       }
    }
}
/*===============*
 * FMI functions *
 *===============*/

const char* fmi3GetVersion(void) {
    static char str[] = {'3','.','0','\0'};
    return str;
}

fmi3Status fmi3SetDebugLogging(fmi3Instance c, fmi3Boolean loggingOn, size_t nCategories, const fmi3String categories[]) {  
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    (void)nCategories;
    (void)categories;

    modelData->loggingOn = loggingOn;
    return fmi3OK;
}

fmi3Instance fmi3InstantiateModelExchange(
    fmi3String                 instanceName,
    fmi3String                 instantiationToken,
    fmi3String                 fmuResourceLocation,
    fmi3Boolean                visible,
    fmi3Boolean                loggingOn,
    fmi3InstanceEnvironment    instanceEnvironment,
    fmi3LogMessageCallback     logMessage) {

    FMUModelData *modelData = NULL;
    const char_T *errmsg = NULL;

    if (!instanceName || strlen(instanceName) == 0) {
        if (loggingOn && logMessage && instanceEnvironment)
            logMessage(instanceEnvironment, fmi3Error, "error","fmi3InstantiateModelExchange: Missing instance name.");
        return NULL;
    }
    if (!instantiationToken || strlen(instantiationToken) == 0) {
        if (loggingOn && logMessage && instanceEnvironment)
            logMessage(instanceEnvironment, fmi3Error, "error","fmi3InstantiateModelExchange: Missing instantiationToken.");
        return NULL;
    }
    if (strcmp(instantiationToken, "{eb02d0f4-8a54-deab-20e0-8ee8e8743911}")) {
        if (loggingOn && logMessage && instanceEnvironment)
            logMessage(instanceEnvironment, fmi3Error, "error", "fmi3InstantiateModelExchange: Wrong instantiationToken.");
        return NULL;
    }
    if (_instance) {
        if (loggingOn && logMessage && instanceEnvironment)
            logMessage(instanceEnvironment, fmi3Error, "error",  "fmi3InstantiateModelExchange: This FMU cannot support instantiating multiple instances in one process.");
        return NULL;
    }
    _instance = modelData = (FMUModelData*)calloc(1, sizeof(FMUModelData));
    if (!modelData) {
        if (loggingOn && logMessage && instanceEnvironment)
            logMessage(instanceEnvironment, fmi3Error, "error",  "fmi3InstantiateModelExchange: Memory allocation error.");
        return NULL;
    }
    modelData->S = MODEL(); /* using static */
    if (modelData->S == NULL) {
        if (loggingOn && logMessage && instanceEnvironment)
              logMessage(instanceEnvironment, fmi3Error, "error","Memory allocation error during model registration");
        return NULL;
    }
    errmsg = (const char_T *) (rtmGetErrorStatus(modelData->S));
    if (errmsg != NULL) {
        if (loggingOn && logMessage && instanceEnvironment)
              logMessage(instanceEnvironment, fmi3Error, "error", "Error during model registration");
        MODEL_TERMINATE();
        return NULL;
    }
    modelData->instanceName = (fmi3String)calloc(strlen(instanceName)+1, sizeof(fmi3Char*));
    if (!modelData->instanceName) {
        if (loggingOn && logMessage && instanceEnvironment)
              logMessage(instanceEnvironment, fmi3Error, "error","fmi3InstantiateModelExchange: Memory allocation error.");
        return NULL;
    }
    strcpy((char *)modelData->instanceName, (char *)instanceName);
    modelData->instantiationToken = (fmi3String)calloc(strlen(instantiationToken)+1, sizeof(fmi3Char*));
    if (!modelData->instantiationToken) {
        if (loggingOn && logMessage && instanceEnvironment)
              logMessage(instanceEnvironment, fmi3Error, "error","fmi3InstantiateModelExchange: Memory allocation error.");
        return NULL;
    }
    strcpy((char *)modelData->instantiationToken, (char *)instantiationToken);
    if (fmuResourceLocation) {
        modelData->resourceLocation = (fmi3String)calloc(strlen(fmuResourceLocation)+1, sizeof(fmi3Char*));
        strcpy((char *)modelData->resourceLocation, (char *)fmuResourceLocation);
    } else {
        modelData->resourceLocation = fmuResourceLocation;
    }
    modelData->logMessage = logMessage;
    modelData->functions  = (FMU2_CallbackFunctions*)calloc(1, sizeof(FMU2_CallbackFunctions));
    modelData->functions->logger = FMU2_loggerWrapper;
    modelData->functions->allocateMemory = calloc;
    modelData->functions->freeMemory = free;
    modelData->functions->stepFinished = NULL;
    modelData->functions->componentEnvironment = instanceEnvironment;
    modelData->instanceEnvironment = instanceEnvironment;
    modelData->visible = visible;
    modelData->eventProcessed  = false;
    modelData->loggingOn = loggingOn;
    modelData->initialized = fmi3False;
    modelData->isDirty = fmi3True;
    modelData->time = 0.0;
    /* initialize variables */
    if (rtmGetStopRequested(modelData->S)) {
          if (loggingOn && logMessage && instanceEnvironment)
                logMessage(instanceEnvironment,fmi3Error, "error", "stop requested in fmi3InstantiateModelExchange");
        return NULL;
    }
    modelData->rList = (fmi3Float64**)calloc(14, sizeof(fmi3Float64*));
    if (!modelData->rList) {
         if (loggingOn && logMessage && instanceEnvironment)
               logMessage(instanceEnvironment, fmi3Error, "error","fmi3InstantiateModelExchange: Memory allocation error.");
        return NULL;
    }
   modelData->rListSize = (int32_T*)calloc(14, sizeof(int32_T));
    if (!modelData->rListSize) {
         if (loggingOn && logMessage && instanceEnvironment)
               logMessage(instanceEnvironment, fmi3Error, "error","fmi3InstantiateModelExchange: Memory allocation error.");
        return NULL;
    }
   modelData->rListDims = (int32_T**)calloc(14, sizeof(int32_T*));
    if (!modelData->rListDims) {
         if (loggingOn && logMessage && instanceEnvironment)
               logMessage(instanceEnvironment, fmi3Error, "error","fmi3InstantiateModelExchange: Memory allocation error.");
        return NULL;
    }
    modelData->rListDims[0] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[0]) {
        return NULL;
    }
    modelData->rListDims[1] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[1]) {
        return NULL;
    }
    modelData->rListDims[2] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[2]) {
        return NULL;
    }
    modelData->rListDims[3] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[3]) {
        return NULL;
    }
    modelData->rListDims[4] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[4]) {
        return NULL;
    }
    modelData->rListDims[5] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[5]) {
        return NULL;
    }
    modelData->rListDims[6] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[6]) {
        return NULL;
    }
    modelData->rListDims[7] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[7]) {
        return NULL;
    }
    modelData->rListDims[8] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[8]) {
        return NULL;
    }
    modelData->rListDims[9] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[9]) {
        return NULL;
    }
    modelData->rListDims[10] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[10]) {
        return NULL;
    }
    modelData->rListDims[11] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[11]) {
        return NULL;
    }
    modelData->rListDims[12] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[12]) {
        return NULL;
    }
    modelData->rListDims[13] = (int32_T*)calloc(1, sizeof(int32_T));
    if (!modelData->rListDims[13]) {
        return NULL;
    }
    modelData->rOutput = (fmi3Float64*)calloc(2, sizeof(fmi3Float64));
    if (!modelData->rOutput) {
         if (loggingOn && logMessage && instanceEnvironment)
               logMessage(instanceEnvironment, fmi3Error, "error","fmi3InstantiateModelExchange: Memory allocation error.");
        return NULL;
    }
    modelData->derivsBuffer = (fmi3Float64*)calloc(1,sizeof(XDot_DoubleMassSpringDamper_T));
    DoubleMassSpringDamper_M->derivs = (real_T*)modelData->derivsBuffer;
    modelData->rList[0] = (double*)&(DoubleMassSpringDamper_Y.M1);
    modelData->rList[1] = (double*)&(DoubleMassSpringDamper_Y.M2);
#ifdef rtmGetTPtr
    modelData->rList[2] = rtmGetTPtr(DoubleMassSpringDamper_M);
#else
    modelData->rList[2] = &(modelData->time);
#endif
    modelData->rList[3] = (double*)&(((double*)DoubleMassSpringDamper_M->contStates)[0]);
    modelData->rList[4] = (double*)&(((double*)DoubleMassSpringDamper_M->contStates)[1]);
    modelData->rList[5] = (double*)&(((double*)DoubleMassSpringDamper_M->contStates)[2]);
    modelData->rList[6] = (double*)&(((double*)DoubleMassSpringDamper_M->contStates)[3]);
    modelData->rList[7] = (double*)&(((double*)DoubleMassSpringDamper_M->derivs)[0]);
    modelData->rList[8] = (double*)&(((double*)DoubleMassSpringDamper_M->derivs)[1]);
    modelData->rList[9] = (double*)&(((double*)DoubleMassSpringDamper_M->derivs)[2]);
    modelData->rList[10] = (double*)&(((double*)DoubleMassSpringDamper_M->derivs)[3]);
    modelData->rList[11] = (double*)&(DoubleMassSpringDamper_P.b);
    modelData->rList[12] = (double*)&(DoubleMassSpringDamper_P.k);
    modelData->rList[13] = (double*)&(DoubleMassSpringDamper_P.m);
    modelData->rListSize[0] = 1;
    modelData->rListSize[1] = 1;
    modelData->rListSize[2] = 1;
    modelData->rListSize[3] = 1;
    modelData->rListSize[4] = 1;
    modelData->rListSize[5] = 1;
    modelData->rListSize[6] = 1;
    modelData->rListSize[7] = 1;
    modelData->rListSize[8] = 1;
    modelData->rListSize[9] = 1;
    modelData->rListSize[10] = 1;
    modelData->rListSize[11] = 1;
    modelData->rListSize[12] = 1;
    modelData->rListSize[13] = 1;
    modelData->rListDims[0][0]  = 1;
    modelData->rListDims[1][0]  = 1;
    modelData->rListDims[2][0]  = 1;
    modelData->rListDims[3][0]  = 1;
    modelData->rListDims[4][0]  = 1;
    modelData->rListDims[5][0]  = 1;
    modelData->rListDims[6][0]  = 1;
    modelData->rListDims[7][0]  = 1;
    modelData->rListDims[8][0]  = 1;
    modelData->rListDims[9][0]  = 1;
    modelData->rListDims[10][0]  = 1;
    modelData->rListDims[11][0]  = 1;
    modelData->rListDims[12][0]  = 1;
    modelData->rListDims[13][0]  = 1;
    fmu_syncToBuffer();


    return modelData;
}


fmi3Instance fmi3InstantiateScheduledExecution(
    fmi3String                     instanceName,
    fmi3String                     instantiationToken,
    fmi3String                     resourcePath,
    fmi3Boolean                    visible,
    fmi3Boolean                    loggingOn,
    fmi3InstanceEnvironment        instanceEnvironment,
    fmi3LogMessageCallback         logMessage,
    fmi3ClockUpdateCallback        clockUpdate,
    fmi3LockPreemptionCallback     lockPreemption,
    fmi3UnlockPreemptionCallback   unlockPreemption) {
    (void)(instanceName);
    (void)(instantiationToken);
    (void)(resourcePath);
    (void)(visible);
    (void)(loggingOn);
    (void)(instanceEnvironment);
    (void)(logMessage);
    (void)(clockUpdate);
    (void)(lockPreemption);
    (void)(unlockPreemption);
    return NULL;
}

fmi3Instance fmi3InstantiateCoSimulation(fmi3String instanceName,
    fmi3String                 instantiationToken,
    fmi3String                 fmuResourceLocation,
    fmi3Boolean                visible,
    fmi3Boolean                loggingOn,
    fmi3Boolean                eventModeUsed,
    fmi3Boolean                earlyReturnAllowed,
    const fmi3ValueReference   requiredIntermediateVariables[],
    size_t                     nRequiredIntermediateVariables,
    fmi3InstanceEnvironment    instanceEnvironment,
    fmi3LogMessageCallback     logMessage,
    fmi3IntermediateUpdateCallback intermediateUpdate) {

    (void)(instanceName);
    (void)(instantiationToken);
    (void)(fmuResourceLocation);
    (void)(visible);
    (void)(loggingOn);
    (void)(eventModeUsed);
    (void)(earlyReturnAllowed);
    (void)(requiredIntermediateVariables);
    (void)(nRequiredIntermediateVariables);
    (void)(instanceEnvironment);
    (void)(logMessage);
    (void)(intermediateUpdate);
    return NULL;
}

void fmi3FreeInstance(fmi3Instance c) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    const char_T *errStatus = NULL;
    int i;
    
    if (!modelData) return;
    errStatus = (const char_T *) (rtmGetErrorStatus(modelData->S));
    
    if (errStatus != NULL && strcmp(errStatus, "Simulation finished")) {
        if(modelData->loggingOn && modelData->logMessage)
            modelData->logMessage(modelData->instanceEnvironment, fmi3Error, "error", errStatus);

        MODEL_TERMINATE();
        return;
    }    
    MODEL_TERMINATE();
    
    free((void*)modelData->instanceName);
    free((void*)modelData->instantiationToken);
    free((void*)modelData->resourceLocation);
    free((void*)modelData->rList);
    free((void*)modelData->rListSize);
    for(i=0; i<14; i++)
       free((void*)modelData->rListDims[i]);
    free((void*)modelData->rListDims);
    free((void*)modelData->rOutput);
    free((void*)modelData->derivsBuffer);
    free((void*)modelData->functions);
    free((void*)modelData);
    _instance = NULL;
}

fmi3Status fmi3EnterConfigurationMode(fmi3Instance c ) {
    (void)c;
    return fmi3OK;
}

fmi3Status fmi3ExitConfigurationMode(fmi3Instance c) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    return fmi3OK;
}

fmi3Status fmi3EnterInitializationMode(fmi3Instance c, fmi3Boolean toleranceDefined, fmi3Float64 tolerance,
                                       fmi3Float64 startTime, fmi3Boolean stopTimeDefined, fmi3Float64 stopTime) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    if (fabs(startTime) > 1.0E-7) {
        if (modelData->loggingOn && modelData->logMessage)
            modelData->logMessage(modelData->instanceEnvironment, fmi3Error, "error", "start time is not zero.");
        return fmi3Error;
    }

    modelData->time = startTime;
    MODEL_INITIALIZE();
    fmu_syncToBuffer();
    modelData->initialized = fmi3True;
    return fmi3OK;
}

fmi3Status fmi3ExitInitializationMode(fmi3Instance c) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    if (rtmGetStopRequested(modelData->S)) {
        if(modelData->loggingOn && modelData->logMessage)
            modelData->logMessage(modelData->instanceEnvironment, fmi3Error, "error", "stop requested in fmi3ExitInitializationMode");
        return fmi3Error;
    }
    modelData->eventProcessed = true;
    return fmi3OK;
}

fmi3Status fmi3EnterStepMode(fmi3Instance c ) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    return fmi3OK;
}

fmi3Status fmi3EnterEventMode(fmi3Instance c) {
    (void)c;
    return fmi3OK;
}

fmi3Status fmi3Terminate(fmi3Instance c) {
    (void)c;
    return fmi3OK;
}

fmi3Status fmi3Reset(fmi3Instance c) {

    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    const char_T *errmsg = (const char_T *) (rtmGetErrorStatus(modelData->S));
    /* Reset model data */
    if (errmsg != NULL && strcmp(errmsg, "Simulation finished")) {
        if(modelData->loggingOn && modelData->logMessage)
            modelData->logMessage(modelData->instanceEnvironment, fmi3Error, "error", errmsg);

        MODEL_TERMINATE();
        return fmi3Error;
    }    
    MODEL_TERMINATE();
    
    modelData->S = MODEL(); /* using static */
    if (modelData->S == NULL) {
        if(modelData->loggingOn && modelData->logMessage)
            modelData->logMessage(modelData->instanceEnvironment, fmi3Error, "error","Memory allocation error during model registration");
        return fmi3Error;
    }
    errmsg = (const char_T *) (rtmGetErrorStatus(modelData->S));
    if (errmsg != NULL) {
        if(modelData->loggingOn && modelData->logMessage)
            modelData->logMessage(modelData->instanceEnvironment, fmi3Error, "error", errmsg);
        MODEL_TERMINATE();
        return fmi3Error;
    }
    modelData->isDirty = fmi3True;
    DoubleMassSpringDamper_M->derivs = (real_T*)modelData->derivsBuffer;
    modelData->rList[0] = (double*)&(DoubleMassSpringDamper_Y.M1);
    modelData->rList[1] = (double*)&(DoubleMassSpringDamper_Y.M2);
#ifdef rtmGetTPtr
    modelData->rList[2] = rtmGetTPtr(DoubleMassSpringDamper_M);
#else
    modelData->rList[2] = &(modelData->time);
#endif
    modelData->rList[3] = (double*)&(((double*)DoubleMassSpringDamper_M->contStates)[0]);
    modelData->rList[4] = (double*)&(((double*)DoubleMassSpringDamper_M->contStates)[1]);
    modelData->rList[5] = (double*)&(((double*)DoubleMassSpringDamper_M->contStates)[2]);
    modelData->rList[6] = (double*)&(((double*)DoubleMassSpringDamper_M->contStates)[3]);
    modelData->rList[7] = (double*)&(((double*)DoubleMassSpringDamper_M->derivs)[0]);
    modelData->rList[8] = (double*)&(((double*)DoubleMassSpringDamper_M->derivs)[1]);
    modelData->rList[9] = (double*)&(((double*)DoubleMassSpringDamper_M->derivs)[2]);
    modelData->rList[10] = (double*)&(((double*)DoubleMassSpringDamper_M->derivs)[3]);
    modelData->rList[11] = (double*)&(DoubleMassSpringDamper_P.b);
    modelData->rList[12] = (double*)&(DoubleMassSpringDamper_P.k);
    modelData->rList[13] = (double*)&(DoubleMassSpringDamper_P.m);
    modelData->rListSize[0] = 1;
    modelData->rListSize[1] = 1;
    modelData->rListSize[2] = 1;
    modelData->rListSize[3] = 1;
    modelData->rListSize[4] = 1;
    modelData->rListSize[5] = 1;
    modelData->rListSize[6] = 1;
    modelData->rListSize[7] = 1;
    modelData->rListSize[8] = 1;
    modelData->rListSize[9] = 1;
    modelData->rListSize[10] = 1;
    modelData->rListSize[11] = 1;
    modelData->rListSize[12] = 1;
    modelData->rListSize[13] = 1;
    modelData->rListDims[0][0]  = 1;
    modelData->rListDims[1][0]  = 1;
    modelData->rListDims[2][0]  = 1;
    modelData->rListDims[3][0]  = 1;
    modelData->rListDims[4][0]  = 1;
    modelData->rListDims[5][0]  = 1;
    modelData->rListDims[6][0]  = 1;
    modelData->rListDims[7][0]  = 1;
    modelData->rListDims[8][0]  = 1;
    modelData->rListDims[9][0]  = 1;
    modelData->rListDims[10][0]  = 1;
    modelData->rListDims[11][0]  = 1;
    modelData->rListDims[12][0]  = 1;
    modelData->rListDims[13][0]  = 1;
    fmu_syncToBuffer();

    if (rtmGetStopRequested(modelData->S)) {
        if(modelData->loggingOn && modelData->logMessage)
            modelData->logMessage(modelData->instanceEnvironment, fmi3Error, "error", "stop requested in fmi3Reset");
        return fmi3Error;
    }
    return fmi3OK;
}

fmi3Status fmi3GetNumberOfVariableDependencies(fmi3Instance c, fmi3ValueReference valueReference, size_t* nDependencies) {
    (void)c;
    (void)valueReference;
    (void)nDependencies;
    return fmi3OK;
}

fmi3Status fmi3GetVariableDependencies(fmi3Instance c, fmi3ValueReference dependent,
                                      size_t elementIndicesOfDependent[], fmi3ValueReference independents[],
                                      size_t elementIndicesOfIndependents[], fmi3DependencyKind dependencyKinds[], size_t nDependencies){
    (void)c;
    (void)dependent;
    (void)elementIndicesOfDependent;
    (void)independents;
    (void)elementIndicesOfIndependents;
    (void)dependencyKinds;
    (void)nDependencies;
    return fmi3OK;
}

/*Write fmi3Get and fmi3Set interfaces for supported data types*/
 
fmi3Status fmi3GetFloat64 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3Float64 value[], size_t nv ) {
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t i;
    int counter = 0;
    if (nvr != 0 && (!value || !vr)) {
        if(modelData->loggingOn && modelData->logMessage)
            modelData->logMessage(modelData->instanceEnvironment, fmi3Error, "error", "invalid memory access in fmi3GetFloat64");
        return fmi3Error;
    }
    for (i = 0; i < nvr; i++) {
        if (vr[i] >= 14 || vr[i] < 0) {
            if(modelData->loggingOn && modelData->logMessage)
                modelData->logMessage(modelData->instanceEnvironment, fmi3Error, "error", "valueReference out of range in fmi3GetFloat64");
            return fmi3Error;
        }
    }
    if (modelData->isDirty == fmi3True) {
        rtOneStep(modelData->S);;
        modelData->isDirty = fmi3False;
    }
    for (i = 0; i < nvr; i++) {
       size_t idx = vr[i]-0;
        updateArrayData(modelData->idxVector, modelData->inDim, modelData->rList[idx],  modelData->rListSize[idx], modelData->rListDims[idx], (void*)(value+counter), true, sizeof(fmi3Float64), NULL );
        counter += modelData->rListSize[idx];
    }
    if ( counter != nv ) {
        if(modelData->loggingOn && modelData->logMessage)
            modelData->logMessage(modelData->instanceEnvironment, fmi3Error, "error", "incorrect num of nv in fmi3GetFloat64");
        return fmi3Error;
    }
    printLogMsg(c, vr, nvr, "getFloat64", value, 0, modelData->rListSize);
    return fmi3OK;
}

 
fmi3Status fmi3SetFloat64 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const fmi3Float64 value[], size_t nv ) {
    (void)nv;
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t i;
    int counter = 0;
    fmi3Boolean is_diff_value = fmi3False;
    if (nvr != 0 && (!value || !vr)) {
        if(modelData->loggingOn && modelData->logMessage)
            modelData->logMessage(modelData->instanceEnvironment, fmi3Error, "error", "invalid memory access in fmi3SetFloat64");
        return fmi3Error;
    }
    for (i = 0; i < nvr; i++) {
        if (vr[i] >= 14 || vr[i] < 0) {
            if(modelData->loggingOn && modelData->logMessage)
                 modelData->logMessage(modelData->instanceEnvironment, fmi3Error, "error", "valueReference out of range in fmi3SetFloat64");
            return fmi3Error;
        }
    }
    for (i = 0; i < nvr; i++) {
       size_t idx = vr[i]-0;
        updateArrayData(modelData->idxVector, modelData->inDim, modelData->rList[idx],  modelData->rListSize[idx], modelData->rListDims[idx], (void*)(value+counter), false, sizeof(fmi3Float64), &is_diff_value );
        counter += modelData->rListSize[idx];
   }
    printLogMsg(c, vr, nvr, "setFloat64", value, 0, modelData->rListSize);
    if (is_diff_value) modelData->isDirty = fmi3True;
    return fmi3OK;
}

 
fmi3Status fmi3GetFloat32 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3Float32 value[], size_t nv ) {
    /*model do not have variables of data type fmi3Float32*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3SetFloat32 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const fmi3Float32 value[], size_t nv ) {
    /*model do not have variables of data type fmi3Float32*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3GetInt8 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3Int8 value[], size_t nv ) {
    /*model do not have variables of data type fmi3Int8*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3SetInt8 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const fmi3Int8 value[], size_t nv ) {
    /*model do not have variables of data type fmi3Int8*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3GetUInt8 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3UInt8 value[], size_t nv ) {
    /*model do not have variables of data type fmi3UInt8*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3SetUInt8 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const fmi3UInt8 value[], size_t nv ) {
    /*model do not have variables of data type fmi3UInt8*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3GetInt16 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3Int16 value[], size_t nv ) {
    /*model do not have variables of data type fmi3Int16*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3SetInt16 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const fmi3Int16 value[], size_t nv ) {
    /*model do not have variables of data type fmi3Int16*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3GetUInt16 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3UInt16 value[], size_t nv ) {
    /*model do not have variables of data type fmi3UInt16*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3SetUInt16 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const fmi3UInt16 value[], size_t nv ) {
    /*model do not have variables of data type fmi3UInt16*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3GetInt32 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3Int32 value[], size_t nv ) {
    /*model do not have variables of data type fmi3Int32*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3SetInt32 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const fmi3Int32 value[], size_t nv ) {
    /*model do not have variables of data type fmi3Int32*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3GetUInt32 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3UInt32 value[], size_t nv ) {
    /*model do not have variables of data type fmi3UInt32*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3SetUInt32 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const fmi3UInt32 value[], size_t nv ) {
    /*model do not have variables of data type fmi3UInt32*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3GetInt64 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3Int64 value[], size_t nv ) {
    /*model do not have variables of data type fmi3Int64*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3SetInt64 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const fmi3Int64 value[], size_t nv ) {
    /*model do not have variables of data type fmi3Int64*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3GetUInt64 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3UInt64 value[], size_t nv ) {
    /*model do not have variables of data type fmi3UInt64*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3SetUInt64 (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const fmi3UInt64 value[], size_t nv ) {
    /*model do not have variables of data type fmi3UInt64*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3GetBoolean (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3Boolean value[], size_t nv ) {
    /*model do not have variables of data type fmi3Boolean*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

 
fmi3Status fmi3SetBoolean (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const fmi3Boolean value[], size_t nv ) {
    /*model do not have variables of data type fmi3Boolean*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

fmi3Status fmi3GetString (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3String value[], size_t nv) {
    /*model do not have variables of data type fmi3String*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

fmi3Status fmi3SetString (fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, const fmi3String value[], size_t nv) {
    /*model do not have variables of data type fmi3String*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)value;
    (void)nv;
    return fmi3OK;
}

fmi3Status fmi3GetBinary(fmi3Instance c, const fmi3ValueReference valueReferences[],size_t nValueReferences,size_t valueSizes[],fmi3Binary values[],size_t nValues) {
    (void)c;
    (void)valueReferences;
    (void)nValueReferences;
    (void)valueSizes;
    (void)values;
    (void)nValues;
    return fmi3OK;
}

fmi3Status fmi3SetBinary(fmi3Instance c, const fmi3ValueReference valueReferences[],size_t nValueReferences,const size_t valueSizes[],const fmi3Binary values[],size_t nValues) {
    (void)c;
    (void)valueReferences;
    (void)nValueReferences;
    (void)valueSizes;
    (void)values;
    (void)nValues;
    return fmi3OK;
}

fmi3Status fmi3GetClock(fmi3Instance c, const fmi3ValueReference vr[],size_t nvr,fmi3Clock values[]) {
    /*model do not have variables of data type fmi3Clock*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)values;
    return fmi3OK;
}

fmi3Status fmi3SetClock(fmi3Instance c, const fmi3ValueReference vr[],size_t nvr,const fmi3Clock values[]) {
    /*model do not have variables of data type fmi3Clock*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)values;
    return fmi3OK;
}

fmi3Status fmi3GetFMUState (fmi3Instance c, fmi3FMUState* FMUState) {
    (void)c;
    (void)FMUState;
    return fmi3OK;
}

fmi3Status fmi3SetFMUState (fmi3Instance c, fmi3FMUState FMUState) {
    (void)c;
    (void)FMUState;
    return fmi3OK;
}

fmi3Status fmi3FreeFMUState(fmi3Instance c, fmi3FMUState* FMUState) {
    (void)c;
    (void)c;
    free(*FMUState);
    return fmi3OK;
}

fmi3Status fmi3SerializedFMUStateSize(fmi3Instance c, fmi3FMUState FMUState, size_t *size) {
    (void)c;
   (void)c;
   return fmi3OK;
}

fmi3Status fmi3SerializeFMUState (fmi3Instance c, fmi3FMUState FMUState, fmi3Byte serializedState[], size_t size) {
    (void)c;
    (void)size;
   (void)size;
   (void)c;
   (void)FMUState;
    return fmi3OK;
}

fmi3Status fmi3DeserializeFMUState (fmi3Instance c, const fmi3Byte serializedState[], size_t size,
                                    fmi3FMUState* FMUState) {
    (void)c;
    (void)FMUState;
    return fmi3OK;
}

fmi3Status fmi3GetDirectionalDerivative(fmi3Instance c, const fmi3ValueReference vUnknown_ref[], size_t nUnknown,
                                        const fmi3ValueReference vKnown_ref[] , size_t nKnown,
                                        const fmi3Float64  dvKnown[], size_t nSeed, fmi3Float64  dvUnknown[], size_t nSensitivity) {
    (void)c;
    (void)vUnknown_ref;
    (void)nUnknown;
    (void)vKnown_ref;
    (void)nKnown;
    (void)dvKnown;
    (void)dvUnknown;
    return fmi3OK;
}

fmi3Status fmi3GetAdjointDerivative(fmi3Instance c, const fmi3ValueReference vUnknown_ref[], size_t nUnknown,
                                        const fmi3ValueReference vKnown_ref[] , size_t nKnown,
                                        const fmi3Float64  dvKnown[], size_t nSeed, fmi3Float64  dvUnknown[], size_t nSensitivity) {
    (void)c;
    (void)vUnknown_ref;
    (void)nUnknown;
    (void)vKnown_ref;
    (void)nKnown;
    (void)dvKnown;
    (void)dvUnknown;
    return fmi3OK;
}

fmi3Status fmi3UpdateDiscreteStates(fmi3Instance c, fmi3Boolean* discreteStatesNeedUpdate, fmi3Boolean* terminateSimulation,
                                    fmi3Boolean* nominalsOfContinuousStatesChanged , fmi3Boolean* valuesOfContinuousStatesChanged,
                                    fmi3Boolean* nextEventTimeDefined, fmi3Float64* nextEventTime) {
    int ii;
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    if(modelData->loggingOn && modelData->logMessage)
        modelData->logMessage(modelData->instanceEnvironment,fmi3OK, "info", "UpdateDiscreteStates");


    *discreteStatesNeedUpdate = false;
    *terminateSimulation = false;
    *nominalsOfContinuousStatesChanged = false;
    *valuesOfContinuousStatesChanged = false;
    *nextEventTimeDefined = false;
    *nextEventTime = 0;
    rtOneStep(modelData->S);;
    DoubleMassSpringDamper_update();
    modelData->isDirty = false;
 
    return fmi3OK;
}
 
fmi3Status fmi3EvaluateDiscreteStates(fmi3Instance c) {
    (void)c;
    return fmi3OK;
}

/* ---------------------------------------------------------------------------
 * Functions for FMI for Co-Simulation
 * ---------------------------------------------------------------------------
 */

fmi3Status fmi3GetOutputDerivatives(fmi3Instance c, const fmi3ValueReference vr[], size_t nvr,
                                    const fmi3Int32 order[], fmi3Float64 value[], size_t nValues) {
    (void)c;
    (void)c;
    (void)vr;
    (void)nvr;
    (void)order;
    (void)value;
    (void)nValues;
    return fmi3OK;
}

/*api related to FMI 3.0 clock*/
fmi3Status fmi3GetIntervalDecimal(fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3Float64 intervals[], fmi3IntervalQualifier qualifiers[]) {
    /*model do not have variables of data type fmi3Clock*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)intervals;
    (void)qualifiers;
    return fmi3OK;
}

/*api related to FMI 3.0 Clock*/
fmi3Status fmi3SetIntervalDecimal(fmi3Instance instance, const fmi3ValueReference valueReferences[], size_t nValueReferences, const fmi3Float64 intervals[]) {
    (void)(instance);
    (void)(valueReferences);
    (void)(nValueReferences);
    (void)(intervals);
    return fmi3OK;
}

/*api related to FMI 3.0 Clock*/
fmi3Status fmi3GetShiftDecimal(fmi3Instance c, const fmi3ValueReference vr[], size_t nvr, fmi3Float64 shifts[]) {
    /*model do not have variables of data type fmi3Clock*/
    (void)c;
    (void)vr;
    (void)nvr;
    (void)shifts;
    return fmi3OK;
}

/*api related to FMI 3.0 Clock*/
fmi3Status fmi3SetShiftDecimal(fmi3Instance instance, const fmi3ValueReference valueReferences[], size_t nValueReferences, const fmi3Float64 shifts[]) {
    (void)(instance);
    (void)(valueReferences);
    (void)(nValueReferences);
    (void)(shifts);
    return fmi3OK;
}

/*api related to FMI 3.0 Clock*/
fmi3Status fmi3GetIntervalFraction(fmi3Instance instance, const fmi3ValueReference valueReferences[], size_t nValueReferences, fmi3UInt64 intervalCounters[], fmi3UInt64 resolutions[], fmi3IntervalQualifier qualifiers[]) {
    (void)(instance);
    (void)(valueReferences);
    (void)(nValueReferences);
    (void)(intervalCounters);
    (void)(resolutions);
    (void)(qualifiers);
    return fmi3OK;
}

/*api related to FMI 3.0 Clock*/
fmi3Status fmi3SetIntervalFraction(fmi3Instance instance, const fmi3ValueReference valueReferences[], size_t nValueReferences, const fmi3UInt64 intervalCounters[], const fmi3UInt64 resolutions[]) {
    (void)(instance);
    (void)(valueReferences);
    (void)(nValueReferences);
    (void)(intervalCounters);
    (void)(resolutions);
    return fmi3OK;
}

/*api related to FMI 3.0 Clock*/
fmi3Status fmi3GetShiftFraction(fmi3Instance instance, const fmi3ValueReference valueReferences[], size_t nValueReferences, fmi3UInt64 shiftCounters[], fmi3UInt64 resolutions[]) {
    (void)(instance);
    (void)(valueReferences);
    (void)(nValueReferences);
    (void)(shiftCounters);
    (void)(resolutions);
    return fmi3OK;
}

/*api related to FMI 3.0 Clock*/
fmi3Status fmi3SetShiftFraction(fmi3Instance instance, const fmi3ValueReference valueReferences[], size_t nValueReferences, const fmi3UInt64 shiftCounters[], const fmi3UInt64 resolutions[]) {
    (void)(instance);
    (void)(valueReferences);
    (void)(nValueReferences);
    (void)(shiftCounters);
    (void)(resolutions);
    return fmi3OK;
}
 
fmi3Status fmi3DoStep(fmi3Instance c, fmi3Float64 currentCommunicationPoint,
                      fmi3Float64 communicationStepSize, fmi3Boolean noSetFMUStatePriorToCurrentPoint,
                      fmi3Boolean* eventHandlingNeeded, fmi3Boolean* terminateSimulation,
                      fmi3Boolean* earlyReturn, fmi3Float64* lastSuccessfulTime) {
    (void)c;
    (void)currentCommunicationPoint;
    (void)communicationStepSize;
    (void)noSetFMUStatePriorToCurrentPoint;
    return fmi3OK;
}

/* ---------------------------------------------------------------------------
 * Functions for FMI for Model Exchange
 * ---------------------------------------------------------------------------
 */

fmi3Status fmi3CompletedIntegratorStep(fmi3Instance c, fmi3Boolean noSetFMUStatePriorToCurrentPoint, fmi3Boolean* enterEventMode, fmi3Boolean* terminateSimulation) {
    (void)c;
    (void)noSetFMUStatePriorToCurrentPoint;
    *enterEventMode = fmi3True;
    *terminateSimulation = fmi3False;
    return fmi3OK;
}

fmi3Status fmi3EnterContinuousTimeMode(fmi3Instance c) {
    (void)c;
    return fmi3OK;
}

fmi3Status fmi3GetContinuousStates(fmi3Instance c, fmi3Float64  x[], size_t nx) {
    fmi3ValueReference vr[4] = {3,4,5,6};
    (void)c;
    size_t nvr = 4;
    return fmi3GetFloat64(c,vr,nvr,x,nx);
}

fmi3Status fmi3GetContinuousStateDerivatives(fmi3Instance c, fmi3Float64 derivatives[], size_t nx) {
    fmi3ValueReference vr[4] = {7,8,9,10};
    (void)c;
    FMUModelData *modelData = (FMUModelData *)c;
    _instance = modelData;
    size_t nvr = 4;
    return fmi3GetFloat64(c,vr,nvr,derivatives,nx);
}

fmi3Status fmi3GetEventIndicators(fmi3Instance c, fmi3Float64  eventIndicators[], size_t ni) {
    (void)c;
    (void)eventIndicators;
    (void)ni;
    return fmi3OK;
}

fmi3Status fmi3GetNominalsOfContinuousStates(fmi3Instance c, fmi3Float64 x_nominal[], size_t nx) {
    int i;
    (void)c;
    for (i = 0; i < nx; i++) x_nominal[i] = 1.0;
    return fmi3OK;
}

fmi3Status fmi3SetContinuousStates(fmi3Instance c, const fmi3Float64 x[], size_t nx) {
    fmi3ValueReference vr[4] = {3,4,5,6};
    (void)c;
    size_t nvr = 4;
    return fmi3SetFloat64(c,vr,nvr,x,nx);
}

fmi3Status fmi3SetTime(fmi3Instance c, fmi3Float64  time) {
    FMUModelData *modelData = (FMUModelData *)c;
    fmi3ValueReference vr[1] = {2};
    fmi3Float64 x = time;
    modelData->time = time;
    return fmi3SetFloat64(c,vr,1,&x,1);
}
fmi3Status fmi3GetNumberOfEventIndicators(fmi3Instance instance, size_t* nEventIndicators) {
    (void)instance;
    *nEventIndicators = 0;
    return fmi3OK;
}
fmi3Status fmi3GetNumberOfContinuousStates(fmi3Instance instance, size_t* nContinuousStates) {
    (void)instance;
    *nContinuousStates = 4;
    return fmi3OK;
}
/* ---------------------------------------------------------------------------
 * Functions for FMI for Scheduled Execution
 * ---------------------------------------------------------------------------
 */

fmi3Status fmi3ActivateModelPartition(fmi3Instance instance, fmi3ValueReference clockReference, fmi3Float64 activationTime) {
    (void)instance;
    (void)clockReference;
    (void)activationTime;
    return fmi3OK;
}
